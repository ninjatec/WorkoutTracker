@page
@model WorkoutTrackerWeb.Pages.DataPortability.ImportModel
@{
    ViewData["Title"] = "Import Workout Data";
}

<h1>@ViewData["Title"]</h1>

<div class="row">
    <div class="col-md-6">
        <div class="card mb-4">
            <div class="card-body">
                <h5 class="card-title">Import JSON Data</h5>
                <form method="post" enctype="multipart/form-data" id="importForm">
                    <div class="mb-3">
                        <label asp-for="ImportFile" class="form-label">JSON File</label>
                        <input asp-for="ImportFile" class="form-control" type="file" accept=".json" id="jsonFileInput" />
                        <span asp-validation-for="ImportFile" class="text-danger"></span>
                        <div id="fileInfo" class="form-text d-none">
                            <span id="fileSize"></span>
                            <div id="largeFileWarning" class="alert alert-info mt-2 d-none">
                                <i class="fas fa-info-circle"></i> Large file detected. The upload will be processed in the background to avoid timeouts.
                            </div>
                        </div>
                    </div>

                    <div class="form-check mb-3">
                        <input asp-for="SkipExisting" class="form-check-input" type="checkbox" checked />
                        <label asp-for="SkipExisting" class="form-check-label">Skip existing sessions</label>
                    </div>

                    <div class="mb-3">
                        <button type="submit" class="btn btn-primary" id="importButton">Import</button>
                        <a asp-page="./Index" class="btn btn-secondary">Cancel</a>
                    </div>
                </form>
            </div>
        </div>

        @if (!string.IsNullOrEmpty(Model.Message))
        {
            <div class="alert @(Model.Success ? "alert-success" : "alert-danger")" role="alert">
                @Model.Message
                @if (!string.IsNullOrEmpty(Model.ErrorMessage))
                {
                    <div class="mt-2">
                        <strong>Error details:</strong> @Model.ErrorMessage
                    </div>
                }
            </div>
        }
        
        <!-- File Upload Progress -->
        <div id="uploadProgressSection" class="card mb-4 d-none">
            <div class="card-body">
                <h5 class="card-title">Upload Progress</h5>
                <div class="progress mb-3">
                    <div id="uploadProgressBar" class="progress-bar progress-bar-striped progress-bar-animated bg-info" 
                         role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                </div>
                <p id="uploadStatus" class="text-muted">Preparing to upload file...</p>
            </div>
        </div>
        
        <!-- Job Progress Section -->
        <div id="progressSection" class="card mb-4 @(string.IsNullOrEmpty(Model.JobId) ? "d-none" : "")">
            <div class="card-body">
                <h5 class="card-title d-flex justify-content-between align-items-center">
                    Import Progress
                    <span id="connectionStatus" class="badge bg-secondary">Connecting...</span>
                </h5>
                
                <p id="progressStatus">@(Model.JobState ?? "Initializing...")</p>
                
                <div class="progress mb-3">
                    <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" 
                         role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                </div>
                
                <p id="progressDetails" class="text-muted small"></p>
                
                <div id="itemProgress" class="d-none mb-3">
                    <p><span id="processedItems">0</span> of <span id="totalItems">0</span> items processed</p>
                </div>
                
                <div id="errorMessage" class="alert alert-danger d-none"></div>
                
                <div class="mt-3">
                    <p class="text-info">
                        <i class="fas fa-info-circle"></i>
                        The import is running in the background. You can leave this page if you wish.
                    </p>
                </div>
            </div>
        </div>

        @if (Model.Success && Model.ImportedItems.Any())
        {
            <div class="card mt-4">
                <div class="card-header">
                    Import Summary
                </div>
                <div class="card-body">
                    <ul class="list-group list-group-flush">
                        @foreach (var item in Model.ImportedItems)
                        {
                            <li class="list-group-item">@item</li>
                        }
                    </ul>
                </div>
            </div>
        }
    </div>
    
    <div class="col-md-6">
        <div class="card">
            <div class="card-body">
                <h5 class="card-title">Import Instructions</h5>
                <p>To import your workout data:</p>
                <ol>
                    <li>Click "Choose File" and select a JSON file exported from this or another compatible system</li>
                    <li>Check "Skip existing sessions" if you want to avoid duplicates</li>
                    <li>Click "Import" to start the import process</li>
                </ol>
                <p class="mb-0"><strong>Note:</strong> The import process will:</p>
                <ul>
                    <li>Create new exercise types if they don't exist</li>
                    <li>Import all sessions along with sets and reps</li>
                    <li>Match existing exercise types and set types by name</li>
                </ul>
                <div class="alert alert-info mt-3">
                    <i class="fas fa-info-circle"></i> Large imports now run as background jobs and won't time out.
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    @{await Html.RenderPartialAsync("_ValidationScriptsPartial");}
    <script src="~/lib/microsoft/signalr/dist/browser/signalr.min.js"></script>
    <style>
        .importing {
            cursor: wait !important;
        }
        
        .badge.connected {
            background-color: #28a745 !important;
        }
        
        .badge.disconnected {
            background-color: #dc3545 !important;
        }
        
        .badge.reconnecting {
            background-color: #ffc107 !important;
        }
    </style>

    <script>
        // Get form and UI elements
        const form = document.getElementById('importForm');
        const importButton = document.getElementById('importButton');
        const fileInput = document.getElementById('jsonFileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileSize = document.getElementById('fileSize');
        const largeFileWarning = document.getElementById('largeFileWarning');
        
        // Upload progress elements
        const uploadProgressSection = document.getElementById('uploadProgressSection');
        const uploadProgressBar = document.getElementById('uploadProgressBar');
        const uploadStatus = document.getElementById('uploadStatus');
        
        // Import progress elements
        const progressSection = document.getElementById('progressSection');
        const progressBar = document.getElementById('progressBar');
        const progressStatus = document.getElementById('progressStatus');
        const progressDetails = document.getElementById('progressDetails');
        const errorMessage = document.getElementById('errorMessage');
        const connectionStatus = document.getElementById('connectionStatus');
        const processedItems = document.getElementById('processedItems');
        const totalItems = document.getElementById('totalItems');
        const itemProgress = document.getElementById('itemProgress');
        
        // File size threshold for large file handling (5MB)
        const LARGE_FILE_THRESHOLD = 5 * 1024 * 1024;
        
        // File input change handler to show file size
        fileInput.addEventListener('change', function() {
            if (this.files && this.files.length > 0) {
                const file = this.files[0];
                const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);
                
                // Show file info
                fileInfo.classList.remove('d-none');
                fileSize.textContent = `File size: ${fileSizeMB} MB`;
                
                // Show warning for large files
                if (file.size > LARGE_FILE_THRESHOLD) {
                    largeFileWarning.classList.remove('d-none');
                } else {
                    largeFileWarning.classList.add('d-none');
                }
            } else {
                fileInfo.classList.add('d-none');
            }
        });
        
        // SignalR connection
        let connection;
        let isConnected = false;
        let jobRegistered = false;
        let reconnectAttempts = 0;
        let jobStatusCheckInterval = null;
        
        // Initialize connection
        function initializeConnection() {
            // Create the connection
            connection = new signalR.HubConnectionBuilder()
                .withUrl("/importProgressHub")
                .withAutomaticReconnect([0, 2000, 5000, 10000, 30000])
                .build();
                
            // Handle connection status changes
            connection.onreconnecting(error => {
                console.warn("SignalR reconnecting", error);
                connectionStatus.textContent = "Reconnecting...";
                connectionStatus.className = "badge reconnecting bg-warning";
                isConnected = false;
            });
            
            connection.onreconnected(() => {
                console.log("SignalR reconnected");
                connectionStatus.textContent = "Connected";
                connectionStatus.className = "badge connected bg-success";
                isConnected = true;
                
                // Re-register for job updates if we have a jobId
                const jobId = "@Model.JobId";
                if (jobId && !jobRegistered) {
                    registerForJobUpdates(jobId);
                }
                
                // Clear the polling interval if we're reconnected
                clearJobStatusPolling();
            });
            
            connection.onclose((error) => {
                console.error("SignalR connection closed", error);
                connectionStatus.textContent = "Disconnected";
                connectionStatus.className = "badge disconnected bg-danger";
                isConnected = false;
                
                // Show error only if we have an active job
                const jobId = "@Model.JobId";
                if (jobId && !progressBar.classList.contains('bg-success')) {
                    errorMessage.textContent = "Lost connection to server. Your import is still running. The page will check status periodically.";
                    errorMessage.classList.remove('d-none');
                    
                    // Start polling for job status
                    startJobStatusPolling();
                }
            });

            // Handle progress updates from the server
            connection.on("ReceiveProgress", (progress) => {
                console.log("Progress update:", progress);
                
                // Show progress section and hide upload progress
                progressSection.classList.remove('d-none');
                uploadProgressSection.classList.add('d-none');
                
                // Update progress bar
                progressBar.style.width = progress.percentComplete + "%";
                progressBar.setAttribute('aria-valuenow', progress.percentComplete);
                progressBar.textContent = progress.percentComplete + "%";
                
                // Update status text
                progressStatus.textContent = progress.status;
                
                // Show details if available
                if (progress.details) {
                    progressDetails.textContent = progress.details;
                    progressDetails.classList.remove('d-none');
                } else {
                    progressDetails.classList.add('d-none');
                }
                
                // Show item progress if available
                if (progress.totalItems > 0) {
                    itemProgress.classList.remove('d-none');
                    processedItems.textContent = progress.processedItems;
                    totalItems.textContent = progress.totalItems;
                } else {
                    itemProgress.classList.add('d-none');
                }
                
                // Show error message if available
                if (progress.errorMessage) {
                    errorMessage.textContent = progress.errorMessage;
                    errorMessage.classList.remove('d-none');
                    
                    // Change progress bar to red for errors
                    progressBar.classList.remove('bg-info');
                    progressBar.classList.add('bg-danger');
                } else {
                    errorMessage.classList.add('d-none');
                }
                
                // Handle completion
                if (progress.status === "Completed") {
                    progressBar.classList.remove('bg-info');
                    progressBar.classList.add('bg-success');
                    importButton.disabled = false;
                    importButton.textContent = "Import";
                    document.body.classList.remove('importing');
                    
                    // Clear any status polling
                    clearJobStatusPolling();
                    
                    // Refresh page after 3 seconds to show import summary
                    setTimeout(() => {
                        window.location.reload();
                    }, 3000);
                }
                
                // If there's an error, re-enable the form
                if (progress.status === "Error") {
                    importButton.disabled = false;
                    importButton.textContent = "Import";
                    document.body.classList.remove('importing');
                    
                    // Clear any status polling
                    clearJobStatusPolling();
                }
            });
            
            // Handle connection status updates from the server
            connection.on("connectionStatus", (data) => {
                console.log("Connection status update:", data);
                
                if (data.isConnected) {
                    connectionStatus.textContent = "Connected";
                    connectionStatus.className = "badge connected bg-success";
                    isConnected = true;
                } else {
                    connectionStatus.textContent = "Disconnected";
                    connectionStatus.className = "badge disconnected bg-danger";
                    isConnected = false;
                }
            });
            
            // Handle job registration status updates from the server
            connection.on("JobRegistrationStatus", (data) => {
                console.log("Job registration status:", data);
                
                if (data.success) {
                    jobRegistered = true;
                    console.log(data.message);
                } else {
                    jobRegistered = false;
                    console.error("Failed to register for job updates:", data.message);
                    
                    // Try again after a delay if we're still connected
                    if (isConnected && data.jobId) {
                        setTimeout(() => registerForJobUpdates(data.jobId), 3000);
                    }
                }
            });
            
            // Start the connection
            startConnection();
        }
        
        // Function to register for job updates
        function registerForJobUpdates(jobId) {
            if (!jobId || !isConnected) return;
            
            console.log("Attempting to register for updates on job:", jobId);
            
            connection.invoke("RegisterForJobUpdates", jobId)
                .then(() => {
                    console.log("Successfully registered for updates on job:", jobId);
                    jobRegistered = true;
                    
                    // Also show the progress section since we're monitoring a job
                    progressSection.classList.remove('d-none');
                })
                .catch(err => {
                    console.error("Error registering for job updates:", err);
                    // Try again later if we're still connected
                    if (isConnected) {
                        setTimeout(() => registerForJobUpdates(jobId), 3000);
                    }
                });
        }
        
        // Function to start polling for job status updates when SignalR is not available
        function startJobStatusPolling() {
            // Clear any existing interval
            clearJobStatusPolling();
            
            const jobId = "@Model.JobId";
            if (!jobId) return;
            
            console.log("Starting job status polling for job:", jobId);
            
            // Poll every 5 seconds
            jobStatusCheckInterval = setInterval(() => {
                checkJobStatus(jobId);
            }, 5000);
        }
        
        // Function to clear job status polling
        function clearJobStatusPolling() {
            if (jobStatusCheckInterval) {
                clearInterval(jobStatusCheckInterval);
                jobStatusCheckInterval = null;
            }
        }
        
        // Function to check job status via AJAX when SignalR is not available
        function checkJobStatus(jobId) {
            if (!jobId) return;
            
            console.log("Checking job status for:", jobId);
            
            // Make a simple AJAX request to check job status
            fetch(`/api/jobstatus/${jobId}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    console.log("Job status response:", data);
                    
                    if (data.state) {
                        // Update UI based on job state
                        if (data.state === "Succeeded") {
                            // Job completed successfully
                            progressBar.classList.remove('bg-info');
                            progressBar.classList.add('bg-success');
                            progressStatus.textContent = "Import completed successfully";
                            progressBar.style.width = "100%";
                            progressBar.setAttribute('aria-valuenow', 100);
                            progressBar.textContent = "100%";
                            
                            // Refresh the page to show results
                            window.location.reload();
                        } 
                        else if (data.state === "Failed") {
                            // Job failed
                            progressBar.classList.remove('bg-info');
                            progressBar.classList.add('bg-danger');
                            progressStatus.textContent = "Import failed";
                            
                            if (data.errorMessage) {
                                errorMessage.textContent = data.errorMessage;
                                errorMessage.classList.remove('d-none');
                            }
                            
                            // Clear the interval since we have a final state
                            clearJobStatusPolling();
                        }
                        else if (data.state === "Processing" || data.state === "Scheduled" || data.state === "Enqueued") {
                            // Job is still in progress
                            progressStatus.textContent = `Import in progress (Status: ${data.state})`;
                            
                            // If we have progress data available, update the progress bar
                            if (data.progress && typeof data.progress.percentComplete !== 'undefined') {
                                const percent = data.progress.percentComplete;
                                progressBar.style.width = `${percent}%`;
                                progressBar.setAttribute('aria-valuenow', percent);
                                progressBar.textContent = `${percent}%`;
                                
                                if (data.progress.status) {
                                    progressStatus.textContent = data.progress.status;
                                }
                                
                                if (data.progress.details) {
                                    progressDetails.textContent = data.progress.details;
                                }
                            }
                            
                            // Keep the poll running
                        }
                        else {
                            // Unknown state
                            progressStatus.textContent = `Import status: ${data.state}`;
                        }
                    }
                })
                .catch(error => {
                    console.error("Error checking job status:", error);
                    // Don't stop polling on errors, just try again next time
                });
        }
        
        // Start the connection and register for job updates if needed
        function startConnection() {
            console.log("Starting SignalR connection...");
            
            connection.start()
                .then(() => {
                    console.log("SignalR connected!");
                    connectionStatus.textContent = "Connected";
                    connectionStatus.className = "badge connected bg-success";
                    isConnected = true;
                    reconnectAttempts = 0;
                    
                    // Register for job updates if we have a job ID
                    const jobId = "@Model.JobId";
                    if (jobId && !jobRegistered) {
                        registerForJobUpdates(jobId);
                    }
                })
                .catch(err => {
                    console.error("SignalR Connection Error: ", err);
                    connectionStatus.textContent = "Connection Failed";
                    connectionStatus.className = "badge disconnected bg-danger";
                    
                    // If we have a job ID, start polling as fallback
                    const jobId = "@Model.JobId";
                    if (jobId) {
                        startJobStatusPolling();
                    }
                    
                    // Try to reconnect after a delay
                    setTimeout(startConnection, 5000);
                });
        }

        // Simulate upload progress when submitting large files
        function simulateUploadProgress() {
            let progress = 0;
            const interval = setInterval(() => {
                progress += Math.random() * 10;
                if (progress > 100) {
                    progress = 100;
                    clearInterval(interval);
                }
                
                uploadProgressBar.style.width = `${Math.floor(progress)}%`;
                uploadProgressBar.setAttribute('aria-valuenow', Math.floor(progress));
                uploadProgressBar.textContent = `${Math.floor(progress)}%`;
                
                if (progress >= 100) {
                    uploadStatus.textContent = "Upload complete. Processing file...";
                }
            }, 500);
        }

        // New function to handle large file uploads via AJAX
        function uploadLargeFileWithAjax(file) {
            const formData = new FormData();
            formData.append('ImportFile', file);
            formData.append('SkipExisting', document.getElementById('SkipExisting').checked);
            
            // Show upload progress UI
            uploadProgressSection.classList.remove('d-none');
            uploadStatus.textContent = `Uploading ${(file.size / 1024 / 1024).toFixed(2)} MB file...`;
            simulateUploadProgress();
            
            // Add AJAX request headers to avoid 504 timeout
            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/DataPortability/Import?handler=LargeFile', true);
            
            // Get request verification token for CSRF protection
            const token = document.querySelector('input[name="__RequestVerificationToken"]').value;
            xhr.setRequestHeader('X-CSRF-TOKEN', token);
            
            // Send the form data without setting content type - let browser set it with proper boundary
            xhr.onload = function() {
                if (xhr.status === 200) {
                    try {
                        const response = JSON.parse(xhr.responseText);
                        if (response.success && response.jobId) {
                            // Redirect to the status page with the job ID
                            window.location.href = `/DataPortability/Import?jobId=${response.jobId}`;
                        } else {
                            // Show error
                            errorMessage.textContent = response.message || "Upload failed";
                            errorMessage.classList.remove('d-none');
                            importButton.disabled = false;
                            importButton.innerHTML = 'Import';
                            document.body.classList.remove('importing');
                        }
                    } catch (e) {
                        console.error("Error parsing response:", e);
                        errorMessage.textContent = "Error processing server response";
                        errorMessage.classList.remove('d-none');
                        importButton.disabled = false;
                        importButton.innerHTML = 'Import';
                        document.body.classList.remove('importing');
                    }
                } else {
                    // Handle HTTP errors
                    errorMessage.textContent = `Upload failed: Server returned status ${xhr.status}`;
                    errorMessage.classList.remove('d-none');
                    importButton.disabled = false;
                    importButton.innerHTML = 'Import';
                    document.body.classList.remove('importing');
                }
            };
            
            xhr.onerror = function() {
                errorMessage.textContent = "Network error occurred during upload";
                errorMessage.classList.remove('d-none');
                importButton.disabled = false;
                importButton.innerHTML = 'Import';
                document.body.classList.remove('importing');
            };
            
            xhr.upload.onprogress = function(e) {
                if (e.lengthComputable) {
                    const percent = Math.floor((e.loaded / e.total) * 100);
                    uploadProgressBar.style.width = `${percent}%`;
                    uploadProgressBar.setAttribute('aria-valuenow', percent);
                    uploadProgressBar.textContent = `${percent}%`;
                    
                    if (percent >= 100) {
                        uploadStatus.textContent = "Upload complete. Processing file...";
                    }
                }
            };
            
            // Send the form data
            xhr.send(formData);
        }

        // Add form submit handler
        form.addEventListener('submit', function(e) {
            // Make sure we have a file
            if (!fileInput.files || fileInput.files.length === 0) {
                return;
            }

            // Add waiting cursor to body
            document.body.classList.add('importing');
            
            // Disable the import button
            importButton.disabled = true;
            importButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Importing...';
            
            const file = fileInput.files[0];
            
            // For large files, use AJAX upload to avoid timeout
            if (file && file.size > LARGE_FILE_THRESHOLD) {
                e.preventDefault(); // Prevent default form submission
                uploadLargeFileWithAjax(file);
            } else {
                // For smaller files, use standard form submission
                progressSection.classList.remove('d-none');
                progressStatus.textContent = "Submitting import...";
                progressDetails.textContent = "Preparing to process JSON data";
                // Let the form submit naturally
            }
        });
        
        // Initialize SignalR connection
        initializeConnection();
        
        // Show progress section if we have a job ID (background job is running)
        @if (!string.IsNullOrEmpty(Model.JobId))
        {
            <text>
            progressSection.classList.remove('d-none');
            
            // Update initial progress based on job state
            const jobState = "@Model.JobState";
            if (jobState === "Processing" || jobState === "Scheduled" || jobState === "Enqueued") {
                progressStatus.textContent = `Import in progress (Status: ${jobState})`;
                progressBar.classList.add('bg-info');
                progressBar.classList.add('progress-bar-animated');
                progressBar.classList.add('progress-bar-striped');
            }
            else if (jobState === "Succeeded") {
                progressStatus.textContent = "Import completed successfully";
                progressBar.classList.remove('bg-info');
                progressBar.classList.add('bg-success');
                progressBar.style.width = "100%";
                progressBar.setAttribute('aria-valuenow', 100);
                progressBar.textContent = "100%";
            }
            else if (jobState === "Failed") {
                progressStatus.textContent = "Import failed";
                progressBar.classList.remove('bg-info');
                progressBar.classList.add('bg-danger');
                
                @if (!string.IsNullOrEmpty(Model.ErrorMessage))
                {
                    <text>
                    errorMessage.textContent = "@Html.Raw(Json.Serialize(Model.ErrorMessage))";
                    errorMessage.classList.remove('d-none');
                    </text>
                }
            }
            </text>
        }
        
        // Show file size info if we have it from the model
        @if (Model.FileSizeBytes > 0)
        {
            <text>
            const fileSizeMB = (@Model.FileSizeBytes / 1024 / 1024).toFixed(2);
            fileInfo.classList.remove('d-none');
            fileSize.textContent = `File size: ${fileSizeMB} MB`;
            
            if (@Model.FileSizeBytes > LARGE_FILE_THRESHOLD) {
                largeFileWarning.classList.remove('d-none');
            }
            </text>
        }
    </script>
}