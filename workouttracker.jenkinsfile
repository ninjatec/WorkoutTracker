pipeline {
    agent {
        label 'jenkins-ansible'
    }
    
    parameters {
        choice(
            name: 'VERSION_TYPE',
            choices: ['build', 'patch', 'minor', 'major'],
            description: 'Type of version update to perform'
        )
    }
    
    environment {
        DOCKER_REPO = "ninjatec/workout-tracker"
        DOCKER_DEFAULT_PLATFORM = "linux/amd64"
        DOTNET_RUNTIME_IDENTIFIER = "linux-x64"
    }
    
    options {
        // Stop the pipeline if any command returns a non-zero exit code
        skipDefaultCheckout(false)
        timestamps()
        ansiColor('xterm')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }
    
    stages {
        stage('Setup') {
            steps {
                checkout scm
                sh 'set -e; git config --global user.email "marc.coxall@ninjatec.co.uk"'
                sh 'set -e; git config --global user.name "Ninjatec CI"'
            }
        }
        
        stage('Update Version') {
            steps {
                sh "#!/bin/bash\nset -e\n./scripts/update-version.sh ${params.VERSION_TYPE}"
                script {
                    def versionJson = readJSON file: 'version.json'
                    env.VERSION_MAJOR = versionJson.major
                    env.VERSION_MINOR = versionJson.minor
                    env.VERSION_PATCH = versionJson.patch
                    env.VERSION_BUILD = versionJson.build
                    env.VERSION = "${env.VERSION_MAJOR}.${env.VERSION_MINOR}.${env.VERSION_PATCH}.${env.VERSION_BUILD}"
                    env.GIT_COMMIT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    
                    echo "Version set to ${env.VERSION}"
                    echo "Git commit: ${env.GIT_COMMIT}"
                }
            }
        }
        
        
        stage('Build Docker Image') {
            steps {
                sh """#!/bin/bash
                set -e # Exit immediately if a command exits with a non-zero status
                
                dotnet publish \\
                  --os linux \\
                  --arch x64 \\
                  /t:PublishContainer \\
                  -p:ContainerImageName=${env.DOCKER_REPO} \\
                  -p:ContainerImageTag=${env.VERSION} \\
                  -p:PublishTrimmed=false \\
                  -p:ContainerRegistry="" \\
                  -p:TargetArch=x64 \\
                  -p:TargetOS=linux \\
                  --configuration Release
                """
                
                script {
                    // Get built image name
                    def builtImageName = sh(
                        script: "docker images --format '{{.Repository}}:{{.Tag}}' | grep -E '${env.DOCKER_REPO}|workouttrackerweb' | head -n 1",
                        returnStdout: true
                    ).trim()
                    
                    env.BUILT_IMAGE_NAME = builtImageName
                    
                    echo "Found image: ${env.BUILT_IMAGE_NAME}"
                    
                    // Verify image architecture
                    def imageArch = sh(
                        script: "docker inspect ${env.BUILT_IMAGE_NAME} | grep 'Architecture' | head -n 1 | awk -F': ' '{print \$2}' | tr -d '\",}'",
                        returnStdout: true
                    ).trim()
                    
                    if (!(imageArch == "amd64" || imageArch == "x86_64")) {
                        error "Image architecture is ${imageArch}, not x64/amd64 as required"
                    }
                    
                    echo "Confirmed image architecture: ${imageArch}"
                }
            }
        }
        
        stage('Tag Docker Images') {
            steps {
                sh "set -e; docker tag ${env.BUILT_IMAGE_NAME} ${env.DOCKER_REPO}:${env.VERSION}"
                sh "set -e; docker tag ${env.BUILT_IMAGE_NAME} ${env.DOCKER_REPO}:latest"
            }
            post {
                failure {
                    error "Docker image tagging failed. Stopping pipeline."
                }
            }
        }
        
        stage('Push Docker Images') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'Ninjatec-Docker', passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME')]) {
                    sh '''#!/bin/bash
                    set -e # Exit immediately if a command exits with a non-zero status
                    # Using single quotes for the outer script to avoid variable expansion
                    # Then explicitly handling the environment variables within
                    echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin registry.hub.docker.com
                    '''
                    
                    retry(3) {
                        sh "echo /home/jenkins/.docker/config.json"
                        sh "docker push ${env.DOCKER_REPO}:${env.VERSION}"
                    }
                    
                    retry(2) {
                        sh "docker push ${env.DOCKER_REPO}:latest"
                    }
                }
            }
        }
        
        stage('Update Kubernetes Manifests') {
            steps {
                script {
                    // Update the image tag in deployment.yaml
                    sh """#!/bin/bash
                    set -e # Exit immediately if a command exits with a non-zero status
                    sed -i "s|image: ${env.DOCKER_REPO}:.*|image: ${env.DOCKER_REPO}:${env.VERSION}|" ./k8s/deployment.yaml
                    sed -i "s|image: ${env.DOCKER_REPO}:.*|image: ${env.DOCKER_REPO}:${env.VERSION}|" ./k8s/hangfire-worker.yaml
                    """
                }
                
                // Verify file changes were successful
                script {
                    sh """#!/bin/bash
                    set -e
                    if ! grep -q "image: ${env.DOCKER_REPO}:${env.VERSION}" ./k8s/deployment.yaml; then
                        echo "Failed to update deployment.yaml"
                        exit 1
                    fi
                    if ! grep -q "image: ${env.DOCKER_REPO}:${env.VERSION}" ./k8s/hangfire-worker.yaml; then
                        echo "Failed to update hangfire-worker.yaml"
                        exit 1
                    fi
                    """
                }
            }
        }
        
        stage('Update Database Version') {
            steps {
                sh """#!/bin/bash
                set -e # Exit immediately if a command exits with a non-zero status
                
                # Create the SQL file to update the version in the database
                cat > version_update.sql << EOF
-- Recording deployment version
INSERT INTO Deployments (Version, GitCommit, DeploymentDate)
VALUES ('${env.VERSION}', '${env.GIT_COMMIT}', CURRENT_TIMESTAMP);
EOF
                """
                
                withCredentials([usernamePassword(credentialsId: 'wot-db', usernameVariable: 'DB_USER', passwordVariable: 'DB_PASSWORD')]) {
                    sh '''#!/bin/bash
                    set -e # Exit immediately if a command exits with a non-zero status
                    
                    # Export database credentials to environment variables
                    export DB_USER=${DB_USER}
                    export DB_PASSWORD=${DB_PASSWORD}
                    
                    # Run the database update script
                    ./scripts/update-database-version.sh
                    
                    # Verify the script completed successfully
                    if [ $? -ne 0 ]; then
                        echo "Database update failed"
                        exit 1
                    fi
                    '''
                }
            }
            
            post {
                failure {
                    script {
                        currentBuild.result = 'FAILURE'
                        error "Database update failed. Stopping pipeline."
                    }
                }
            }
        }
        
        stage('Commit Version Changes') {
            steps {
                sh """#!/bin/bash
                set -e # Exit immediately if a command exits with a non-zero status
                git add ./k8s/deployment.yaml
                git add ./k8s/hangfire-worker.yaml
                git add ./version.json
                git add ./version_update.sql
                git commit -m "Deploy version ${env.VERSION}"
                """
            }
            post {
                failure {
                    error "Failed to commit version changes. Stopping pipeline."
                }
            }
        }
        
        stage('Push to Git Repository') {
            steps {
                withCredentials([sshUserPrivateKey(credentialsId: 'jenkins', keyFileVariable: 'SSH_KEY')]) {
                    sh """#!/bin/bash
                    set -e # Exit immediately if a command exits with a non-zero status
                    mkdir -p ~/.ssh
                    cp \$SSH_KEY ~/.ssh/id_rsa
                    chmod 600 ~/.ssh/id_rsa
                    ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts
                    git push origin HEAD:main
                    """
                }
                
                script {
                    echo "Git push completed successfully"
                }
            }
        }
        
        
    }
    
    post {
        success {
            echo """====================================================
  Deployment Complete!                               
  Version: ${env.VERSION}                                
  Commit: ${env.GIT_COMMIT}                              
===================================================="""
        }
        failure {
            echo """====================================================
  Deployment FAILED!
  Version: ${env.VERSION}
  Commit: ${env.GIT_COMMIT}
===================================================="""
            
            // Optional: Add notification system here (e.g., email, Slack)
            // slackSend channel: '#deployments', color: 'danger', message: "Deployment of WorkoutTracker v${env.VERSION} failed!"
        }
        aborted {
            echo "Pipeline was aborted"
        }
        always {
            // Clean up Docker images to avoid disk space issues
            sh "docker rmi ${env.DOCKER_REPO}:${env.VERSION} || true"
            sh "docker rmi ${env.DOCKER_REPO}:latest || true"
            sh "docker rmi ${env.BUILT_IMAGE_NAME} || true"
            
            // Clean workspace
            cleanWs()
        }
    }
}